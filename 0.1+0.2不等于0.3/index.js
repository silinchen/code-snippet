// 0.1 + 0.2 在计算机底层会转成二进制后进行操作
/**
 * 正数的二进制转十进制：
 * 1010
 * 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0  = 10
 */

console.log(parseInt('1010', 2)) // 10

/**
 * 负数的二进制转十进制：
 * 10.0101
 * 1*2^1 + 0*2^0 + 0*2^-1 + 1*2^-2 + 0*2^-3 + 1*2^-4 = 2.5625
 */
console.log()

/**
 * 规律：
 * 整数位 当前n位的值 * 2(n-1)
 * 小数位 把当前的不停的乘 2 取整
 * 
 * 
 * 0.1 转二进制：
 * 0.1 * 2 = 0.2 无整数 => 0.0
 * 0.2 * 2 = 0.4 无整数 => 0.00
 * 0.4 * 2 = 0.8 无整数 => 0.000
 * 0.8 * 2 = 1.6 有整数 => 0.0001
 * 0.6 * 2 = 1.2 有整数 => 0.00011
 * 0.2 * 2 = 0.4 无整数 => 0.000110
 * 0.4 * 2 = 0.8 无整数 => 0.0001100
 * 无限循环....   0.000110011001100110011001100110011001100110011001100110011
 */

console.log(0.1.toString(2)) // 0.0001100110011001100110011001100110011001100110011001101

// 双精度浮点数，有限长度，所以会进行截取，截取后的值，因为四舍五入，导致比原来大一些
// 原来 0.000110011001100110011001100110011001100110011001100110011...
// 截取 0.0001100110011001100110011001100110011001100110011001101

// 同理，0.2 转成二进制后也会比原来大些
console.log(0.2.toString(2)) // 0.001100110011001100110011001100110011001100110011001101
// 原来 0.0011001100110011001100110011001100110011001100110011001100...
// 截取 0.001100110011001100110011001100110011001100110011001101

// 两者相加
// 0.0001100110011001100110011001100110011001100110011001101
// 0.001100110011001100110011001100110011001100110011001101
// 0.0100110011001100110011001100110011001100110011001100111

console.log(0.3.toString(2)) // 0.010011001100110011001100110011001100110011001100110011

// 0.1+0.2  -> 0.0100110011001100110011001100110011001100110011001100111
// 0.3      -> 0.010011001100110011001100110011001100110011001100110011
// 将 0.1 + 0.2 的 二进制结果转成十进制：0.30000000000000004
// 所以 0.1 + 0.2 不等于 0.3